---
title: 2020-03-01 코드카타 - 재귀
date: 2020-03-01 01:03:40
category: study
draft: false
---

이번 코드카타 문제는 '재귀(recursion)' 개념을 사용해야 했다.

재귀란 `자신을 정의할 때 자기 자신을 재참조하는 방법을 뜻하며, 이를 프로그래밍에 적용한 재귀 호출의 형태로 많이 사용된다`고 한다(위키피디아). 자기 안에 자기 스스로를 품고 있는 형태를 말하는데 아래 이미지는 싱거운 유머지만 재귀의 의미를 잘 표현하고 있다.

<br>

<div align="center"><img src="./images/reculsive-humor.jpeg" width=300></div>

<br>

정리하자면 재귀는 함수가 작동할 때 그 결과 값을 자기 자신의 인자로 다시 한 번 넘겨주는 식으로 작동한다. 일종의 점화식을 사용하는 셈이다.

```
* 문제
재귀를 사용하여 팩토리얼(factorial)을 구하는 함수를 구현해주세요.
팩토리얼이란 1에서부터 n까지의 정수를 모두 곱한것을 말합니다.

1! = 1
2! = 1 * 2
5! = 1 * 2 * 3 * 4 * 5
```

문제는 팩토리얼을 재귀를 사용해 풀 것을 요구하고 있다. 재귀를 사용하지도 않고도 함수 내에서 풀어낼 수야 있겠지만 생각해보면 반복문 자체가 다르게 표현된 재귀가 아닌가 싶기도 하고.

문제를 재귀적으로 뜯어본다면 이렇게 될 것이다.

```
factorial(5) = 5 * factorial(4)
                    = 4 * factorial(3)
                            ...
```

이렇게 쭉 내려가다가 factorial의 인수가 1이 되었을 때 끝값이 결정 되고 그제서야 선행했던 모든 값들이 결정되어 계산이 거꾸로 올라오게 된다. 1 _ 2 = 2, 2 _ 3 = 6, 6 _ 4 = 24, 24 _ 5 = 120 같은 식이다.

값이 1이 되면 재귀를 멈춰야 하기 때문에 종료조건을 추가해줘야 한다.

그래서 다음과 같이 풀었다.

```javascript
const factorial = n => {
  if (n === 0) {
    return 1
  } else {
    return n * factorial(n - 1)
  }
}
```

모델 솔루션은 다음과 같다. if에 else가 붙었냐 안붙었냐의 차이 뿐이다.

```javascript
const factorial = n => {
  if (n === 0) return 1

  return n * factorial(n - 1)
}
```

참고로 재귀는 앞서 설명한 것 처럼 call stack을 쌓아나가다가 최종 값이 정해졌을 때 바닥부터 계산을 해서 오는데 언어에 따라 콜 스택의 최대 깊이가 다르다. 예를 들어 파이썬의 경우 콜 스택의 최대 깊이가 1000이므로 재귀를 사용해야할 경우 유의해야 한다.

추가로 참고할 글 : [재귀함수를 쓰는 이유](https://medium.com/sjk5766/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EB%A5%BC-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0-ed7c37d01ee0)
