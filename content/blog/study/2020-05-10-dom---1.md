---
title: 2020-05-11 DOM
date: 2020-05-11 21:05:79
category: study
draft: false
---

DOM은 **문서 객체 모델**(Document Object Model)의 준말이다.

DOM에 대해 이야기 하기 위해서는 DOM이 만들어지는 과정, 즉 브라우저의 작동 원리에 대해서 간단하게나마 정리할 필요가 있다. 무엇보다도 DOM에 대해 이해를 통해 **주요 렌더링 경로**를 파악할 수 있고, 추후 웹 사이트 성능 최적화에 활용할 수 있다.

## DOM + CSSOM = Rendering Tree / Layout(Reflow) / Paint

브라우저는 서버와 통신하며 사용자의 요청에 맞는 파일들을 송수신한다. 이를테면 HTML, CSS, JavaScript 및 각종 콘텐츠(이미지, 동영상 등) 말이다. 이렇게 받아온 파일들을 가지고 브라우저는 화면의 렌더링을 시작한다.

구글 웹퍼포먼스 엔지니어 Ilya Grigorik은 브라우저의 렌더링 순서를 다음과 같이 설명했다.

- HTML 마크업을 처리하고 **DOM 트리**를 빌드합니다.
- CSS 마크업을 처리하고 **CSSOM 트리**를 빌드합니다.
- DOM 및 CSSOM을 결합하여 **렌더링 트리**를 형성합니다.
  - 렌더링 트리에는 페이지를 렌더링하는 데 필요한 노드만 포함됩니다.
- 렌더링 트리에서 **레이아웃**을 실행하여 각 노드의 기하학적 형태를 계산합니다.
  - 레이아웃은 각 객체의 정확한 위치 및 크기를 계산합니다.
- 개별 노드를 화면에 **페인트**합니다.
  - 마지막 단계는 최종 렌더링 트리에서 수행되는 페인트이며, 픽셀을 화면에 렌더링합니다.

<br>

<div align="center"><img src="./images/051101.png"/></div>

<br>

앞서 DOM과 CSSOM(CSS Object Model)은 합쳐져 렌더링 트리를 구성한다고 했다. 두 트리는 각각의 모델을 그리는 파서에 의해 생성된다.

> 이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, Javascript을 처리한다. 이것은 script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 script 태그의 위치는 중요한 의미를 갖는다.
> 
> body 요소의 가장 아래에 자바스크립트를 위치시키는 것은 좋은 아이디어이다. 그 이유는 아래와 같다.
> 
> HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.
> 
> DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다.


## React에서는 왜 Virtual DOM을 사용할까?

> 정확히는, DOM 조작이 전체 동작을 비효율적으로 만드는게 아니라, 그 이후에 일어나는 일 때문에, 작업이 더뎌지는거에요.
> 
> (...) 자 이제 DOM 을 조작했을 때 어떤 작업이 이뤄지는지 알겠죠? DOM에 변화생기면, 렌더트리를 재생성하고 (그러면 모든 요소들의 스타일이 다시 계산됩니다) 레이아웃을 만들고 페인팅을 하는 과정이 다시 반복되는거죠.
> DOM 조작의 실제 문제는 각 조작이 레이아웃 변화, 트리 변화와 렌더링을 일으킨다는겁니다. 그래서, 예를 들어 여러분이 30개의 노드를 하나 하나 수정하면, 그 뜻은 30번의 (잠재적인) 레이아웃 재계산과 30번의 (잠재적인) 리렌더링을 초래한다는 것이죠.
> 
> Virtual DOM 은 그냥 뭐 엄청 새로운것도 아니고, 그냥 DOM 차원에서의 더블 버퍼링이랑 다름이 없는거에요. 변화가 일어나면 그걸 오프라인 DOM 트리에 적용시키죠. 이 DOM 트리는 렌더링도 되지 않기때문에 연산 비용이 적어요. 연산이 끝나고나면 그 최종적인 변화를 실제 DOM 에 던져주는거에요. 딱 한번만 한는거에요. 모든 변화를 하나로 묶어서. 그러면, 레이아웃 계산과 리렌더링의 규모는 커지겠지만, 다시 한번 강조하자면 딱 한번만 하는거에요. 바로 이렇게, 하나로 묶어서 적용시키는것이, 연산의 횟수를 줄이는거구요.
> 
> (...) 마지막으로, DOM 관리를 Virtual DOM 이 하도록 함으로써, 컴포넌트가 DOM 조작 요청을 할 때 다른 컴포넌트들과 상호작용을 하지 않아도 되고, 특정 DOM 을 조작할 것 이라던지, 이미 조작했다던지에 대한 정보를 공유 할 필요가 없습니다. 즉, 각 변화들의 동기화 작업을 거치지 않으면서도 모든 작업을 하나로 묶어줄 수 있다는거죠.






참조 :
- [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)
- [FrontEnd-성능최적화-기본](https://ideveloper2.dev/blog/2019-05-18--front-end-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B8%B0%EB%B3%B8/)
- [렌더링 트리 생성, 레이아웃 및 페인트](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko)
- [객체 모델 생성](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko)
- [[번역] 리액트에 대해서 그 누구도 제대로 설명하기 어려운 것 – 왜 Virtual DOM 인가?](https://velopert.com/3236)
