---
title: 2020-05-11 DOM
date: 2020-05-11 21:05:79
category: study
draft: true
---

DOM은 **문서 객체 모델**(Document Object Model)의 준말이다.

DOM에 대해 이야기 하기 위해서는 DOM이 만들어지는 과정, 즉 브라우저의 작동 원리에 대해서 간단하게나마 정리할 필요가 있다. 무엇보다도 DOM에 대해 이해를 통해 **주요 렌더링 경로**를 파악할 수 있고, 추후 웹 사이트 성능 최적화에 활용할 수 있다.

## DOM + CSSOM = Rendering Tree / Layout(Reflow) / Paint

브라우저는 서버와 통신하며 사용자의 요청에 맞는 파일들을 송수신한다. 이를테면 HTML, CSS, JavaScript 및 각종 콘텐츠(이미지, 동영상 등) 말이다. 이렇게 받아온 파일들을 가지고 브라우저는 화면의 렌더링을 시작한다.

구글 웹퍼포먼스 엔지니어 Ilya Grigorik은 브라우저의 렌더링 순서를 다음과 같이 설명했다.

- HTML 마크업을 처리하고 **DOM 트리**를 빌드합니다. (파싱)
- CSS 마크업을 처리하고 **CSSOM 트리**를 빌드합니다. (파싱)
- DOM 및 CSSOM을 결합하여 **렌더링 트리**를 형성합니다. (스타일)
  - 렌더링 트리에는 페이지를 렌더링하는 데 필요한 노드만 포함됩니다.
- 렌더링 트리에서 **레이아웃**을 실행하여 각 노드의 기하학적 형태를 계산합니다. (레이아웃, 리플로우)
  - 레이아웃은 각 객체의 정확한 위치 및 크기를 계산합니다.
- 개별 노드를 화면에 **페인트**합니다. (페인트)
  - 마지막 단계는 최종 렌더링 트리에서 수행되는 페인트이며, 픽셀을 화면에 렌더링합니다.

<br>

<div align="center"><img src="./images/051101.png"/></div>

<br>

앞서 DOM과 CSSOM(CSS Object Model)은 합쳐져 렌더링 트리를 구성한다고 했다. 두 트리는 각각의 모델을 그리는 파서에 의해 생성된다.

<br>

<div align="center"><img src="./images/051104.png"/></div>

<br>이 글을 통해 React 가상 DOM에 대해 알아본 후 배운 것을 활용해 여러분 앱 속도를 높여보세요. React 프레임워크 내부를 철저하게 초보 친화적인 시각에서 소개하는 이 글을 통해 JSX를 명확하게 정의내려 보고, React가 어떻게 렌더링을 결정내리는지 살펴보며, 병목지점을 찾아내는 방법에 대해 설명드리고 흔히 발생하는 실수를 피할 수 있는 몇가지 팁을 공유해 보도록 하겠습니다.

할 HTML이 많은 경우 그렇습니다. (출처 : [객체 모델 생성](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko#domdocument_object_model))

<br>

<div align="center"><img src="./images/051102.png"/></div>

<br>

## 브라우저 로딩 최적화 전략

### 1) body, script

> **자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다.** HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 **DOM 생성 프로세스를 중지**하고 **자바스크립트 엔진으로 제어 권한을 넘긴다.** 제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.
>
> 이처럼 **브라우저는 동기(Synchronous)적으로 HTML, CSS, Javascript을 처리**한다. 이것은 script 태그의 위치에 따라 **블로킹**이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 script 태그의 위치는 중요한 의미를 갖는다.
>
> body 요소의 가장 아래에 자바스크립트를 위치시키는 것은 좋은 아이디어이다. 그 이유는 아래와 같다.
>
> HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.
>
> DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다. (출처 : [브라우저 동작 원리](https://poiemaweb.com/js-browser))

### 2) lazy loading, server side rendering

사용자중심 측정항목 지표
작동되는 걸까? -> 탐색이 성공적으로 시작되었나? 서버가 응답했나?

유용한가? -> 충분한 양의 콘텐츠가 렌더링되어 사용자가 이에 참여할 수 있는가?

사용할 수 있나? -> 사용자가 페이지와 상호작용할 수 있나? 아니면 여전히 로딩 중인가?

즐거운가? -> 상호작용이 매끄럽고 자연스러우며, 지연이나 쟁크 현상(jank)이 없나?

jank 현상이란? : 일반적으로 디스플레이는 1초에 화면을 60번 그린다. 짧게 60fps(frame per second)라는 표현으로 대체할 수 있다.디스플레이가 1초에 60번 바뀌는데 웹페이지가 1초에 10번 그려진다면, 버벅이는 현상이 발생한다. 우리는 이런 현상을 Jank라고 부른다.
위에 해당하는 질문의 해답을 찾기 이전에 필요한 개념들입니다.

FP
First Paint
브라우저가 탐색 전에 화면에 있던것과 시각적으로 다른 어떤것이든 렌더링 할때의 지점
FCP
First Contentful Paint
브라우저가 DOM 콘텐츠를 처음 렌더링할때의 지점 (텍스트, 이미지, svg ..)입니다.
FMP
First Meaningful Paint
주요콘텐츠가 (히어로 요소) 화면에 보여지는 시점입니다.
주요 컨텐츠를 노출하는 css, js가 호출됩니다.
TTI
애플리케이션이 시각적으로 렌더링 되었으며, 사용자 입려에 안정적으로 반응 할수 있는 지점입니다.
TTI를 세분화 하면 FI와 CI로 나눌수 있습니다.

FI : 대부분의 UI가 움직이는 시점입니다.
CI : 최소한 메인스레드가 50ms내에 컨트롤을 확보해 부드러운 반응 가능한 시점입니다.

위의 지표들과 사용자측정항목과의 mapping
작동되는 걸까? -> 첫번째 페인트(FP) / 첫번째 콘텐츠가 있는 페인트(FCP)
유용한가? -> 첫번째 페인트(FMP) / 히어로 요소 타이밍
사용할 수 있나? -> TTI (상호작용 시간)
즐거운가? -> 장기 작업
사용자 기준에서 최적화를 빠르게 할수 있는 방법
lazy loading: FI, CI 향상
server side rendering : FMP 향상

## React에서는 왜 Virtual DOM을 사용할까?

> 정확히는, DOM 조작이 전체 동작을 비효율적으로 만드는게 아니라, 그 이후에 일어나는 일 때문에, 작업이 더뎌지는거에요.
>
> (...) 자 이제 DOM 을 조작했을 때 어떤 작업이 이뤄지는지 알겠죠? DOM에 변화생기면, 렌더트리를 재생성하고 (그러면 모든 요소들의 스타일이 다시 계산됩니다) 레이아웃을 만들고 페인팅을 하는 과정이 다시 반복되는거죠.
>
> DOM 조작의 실제 문제는 각 조작이 레이아웃 변화, 트리 변화와 렌더링을 일으킨다는겁니다. 그래서, 예를 들어 여러분이 30개의 노드를 하나 하나 수정하면, 그 뜻은 30번의 (잠재적인) 레이아웃 재계산과 30번의 (잠재적인) 리렌더링을 초래한다는 것이죠.
>
> Virtual DOM 은 그냥 뭐 엄청 새로운것도 아니고, 그냥 DOM 차원에서의 더블 버퍼링이랑 다름이 없는거에요. 변화가 일어나면 그걸 오프라인 DOM 트리에 적용시키죠. **이 DOM 트리는 렌더링도 되지 않기때문에 연산 비용이 적어요.** 연산이 끝나고나면 그 최종적인 변화를 실제 DOM 에 던져주는거에요. 딱 한번만 한는거에요. 모든 변화를 하나로 묶어서. **그러면, 레이아웃 계산과 리렌더링의 규모는 커지겠지만, 다시 한번 강조하자면 딱 한번만 하는거에요.** 바로 이렇게, 하나로 묶어서 적용시키는것이, 연산의 횟수를 줄이는거구요.
>
> (...) 마지막으로, DOM 관리를 Virtual DOM 이 하도록 함으로써, 컴포넌트가 DOM 조작 요청을 할 때 다른 컴포넌트들과 상호작용을 하지 않아도 되고, 특정 DOM 을 조작할 것 이라던지, 이미 조작했다던지에 대한 정보를 공유 할 필요가 없습니다. 즉, 각 변화들의 동기화 작업을 거치지 않으면서도 모든 작업을 하나로 묶어줄 수 있다는거죠.

참조 :

- [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)
- [FrontEnd-성능최적화-기본](https://ideveloper2.dev/blog/2019-05-18--front-end-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B8%B0%EB%B3%B8/)
- [렌더링 트리 생성, 레이아웃 및 페인트](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko)
- [객체 모델 생성](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko)
- [[번역] 리액트에 대해서 그 누구도 제대로 설명하기 어려운 것 – 왜 Virtual DOM 인가?](https://velopert.com/3236)
